#!/usr/bin/env bash
# shellcheck shell=bash

########################
# Author: Shinichi Okada
# Date: 2021-12-18
# Updated: 2026-01-18
########################

set -euo pipefail

# --------------------
# Bash version check
# --------------------
check_bash_version() {
    local required_version=4
    local current_version="${BASH_VERSINFO[0]}"
    
    if (( current_version < required_version )); then
        cat <<EOF
ERROR: This script requires Bash ${required_version}.0 or higher.
Current version: ${BASH_VERSION}

On macOS, install a newer version:
  brew install bash
  
Then run with:
  /usr/local/bin/bash $0 [OPTIONS]

Or add to your PATH:
  export PATH="/usr/local/bin:\$PATH"
EOF
        exit 1
    fi
}

check_bash_version

# --------------------
# Variables
# --------------------
unset github_username dir repo license_url
script_name="$(basename "${0}")"
dir=""
version="0.4.0"

config_dir="${XDG_CONFIG_HOME:-${HOME}/.config}/gitstart"
gitstart_config="${config_dir}/config"

visibility="public"
branch_name="main"
commit_message="Initial commit"
dry_run=false
quiet=false
prog_lang=""
repo_description=""

# --------------------
# Cleanup on error
# --------------------
# shellcheck disable=SC2329
cleanup_on_error() {
    if [[ -n "${REPO_CREATED:-}" && -n "${repo:-}" && -n "${github_username:-}" ]]; then
        echo ">>> Error occurred. Cleaning up remote repository..."
        gh repo delete "${github_username}/${repo}" --yes 2>/dev/null || true
    fi
}

trap cleanup_on_error ERR

# --------------------
# Helpers
# --------------------
usage() {
    cat <<EOF
Script name: ${script_name}

Description:
============
Automates creating a git repository.
Creates a directory, adds LICENSE/README, initializes git, and pushes to GitHub.

Requirements:
=============
- Bash 4.0 or higher
- gh (GitHub CLI)
- jq (JSON processor)
- git

Usage:
======
${script_name} [OPTIONS]

Options:
========
  -d, --dir DIRECTORY          Directory name or path (use . for current directory)
  -l, --lang LANGUAGE          Programming language for .gitignore
  -p, --private                Create a private repository
  -b, --branch BRANCH          Branch name (default: main)
  -m, --message MESSAGE        Initial commit message
  -desc, --description DESC    Repository description
  --dry-run                    Preview without executing
  -q, --quiet                  Minimal output
  -h, --help                   Show help
  -v, --version                Show version
EOF
}

log() {
    if [[ "${quiet}" == false ]]; then
        echo ">>> ${1}"
    fi
}

error() {
    echo "ERROR: ${1}" >&2
    exit 1
}

# --------------------
# Argument parsing
# --------------------
while (($# > 0)); do
    case "${1}" in
    -d | --dir)
        [[ -n "${2:-}" ]] || error "Option ${1} requires an argument"
        dir="${2}"
        shift 2
        ;;
    -l | --lang)
        [[ -n "${2:-}" ]] || error "Option ${1} requires an argument"
        prog_lang="${2}"
        shift 2
        ;;
    -p | --private)
        visibility="private"
        shift
        ;;
    -b | --branch)
        [[ -n "${2:-}" ]] || error "Option ${1} requires an argument"
        branch_name="${2}"
        shift 2
        ;;
    -m | --message)
        [[ -n "${2:-}" ]] || error "Option ${1} requires an argument"
        commit_message="${2}"
        shift 2
        ;;
    -desc | --description)
        [[ -n "${2:-}" ]] || error "Option ${1} requires an argument"
        repo_description="${2}"
        shift 2
        ;;
    --dry-run)
        dry_run=true
        shift
        ;;
    -q | --quiet)
        quiet=true
        shift
        ;;
    -h | --help)
        usage
        exit 0
        ;;
    -v | --version)
        echo "${version}"
        exit 0
        ;;
    *) error "Unknown option: ${1}" ;;
    esac
done

# --------------------
# Preconditions
# --------------------
command -v gh >/dev/null || error "Please install gh"
command -v jq >/dev/null || error "Please install jq"

# Skip auth check in dry-run mode (allows testing without GitHub auth)
if [[ "${dry_run}" == false ]]; then
    gh auth status &>/dev/null || error "Run 'gh auth login' first"
fi

[[ -n "${dir}" ]] || error "Directory is required (-d)"

if [[ "${dir}" == "." ]]; then
    dir="$(pwd)"
else
    dir="$(pwd)/${dir}"
fi

[[ "${dir}" != "${HOME}" ]] || error "Refusing to create repo in HOME"

# --------------------
# GitHub username
# --------------------
get_github_username() {
    mkdir -p "${config_dir}"

    if [[ -s "${gitstart_config}" ]]; then
        github_username="$(cat "${gitstart_config}")"
        # Only prompt for confirmation if not in dry-run or quiet mode AND in interactive terminal
        if [[ "${quiet}" == false && "${dry_run}" == false && -t 0 ]]; then
            read -r -p "GitHub username (${github_username}) OK? (y/n): " answer
            [[ "${answer}" =~ ^[Yy]$ ]] || {
                read -r -p "Enter GitHub username: " github_username
                echo "${github_username}" >"${gitstart_config}"
            }
        fi
    else
        if [[ "${dry_run}" == false && -t 0 ]]; then
            read -r -p "Enter GitHub username: " github_username
            echo "${github_username}" >"${gitstart_config}"
        else
            # For dry-run or non-interactive, use a placeholder if no config exists
            github_username="<username>"
        fi
    fi
}

get_github_username

repo="$(basename "${dir}")"

# --------------------
# Directory state
# --------------------
dir_exists=false
has_git=false
has_files=false

if [[ -d "${dir}" ]]; then
    dir_exists=true
    [[ -d "${dir}/.git" ]] && has_git=true

    # Check for files (including hidden files)
    if [[ -n "$(ls -A "${dir}" 2>/dev/null)" ]]; then
        has_files=true
    fi
fi

# --------------------
# License selection
# --------------------
license_url="mit"

# Only prompt for license if not in dry-run or quiet mode AND in interactive terminal
if [[ "${dry_run}" == false && "${quiet}" == false && -t 0 ]]; then
    PS3="Select a license: "
    select license in \
        "MIT" "Apache-2.0" "GPLv3" "None" "Quit"; do
        case "${license}" in
        MIT)
            license_url="mit"
            break
            ;;
        Apache-2.0)
            license_url="apache-2.0"
            break
            ;;
        GPLv3)
            license_url="gpl-3.0"
            break
            ;;
        None)
            license_url="none"
            break
            ;;
        Quit)
            exit 0
            ;;
        *)
            echo "Invalid selection. Please try again."
            ;;
        esac
    done
fi

# --------------------
# Dry run
# --------------------
if [[ "${dry_run}" == true ]]; then
    cat <<EOF
=== DRY RUN MODE ===
No changes will be made to your system or GitHub.

Configuration:
--------------
GitHub User:     ${github_username}
Repository:      ${repo}
Directory:       ${dir}
Visibility:      ${visibility}
Branch:          ${branch_name}
Commit Message:  ${commit_message}
Language:        ${prog_lang:-none}
License:         ${license_url}
Description:     ${repo_description:-none}

What would happen:
------------------
1. Create directory: ${dir}
2. Initialize git repository
3. Create .gitignore (${prog_lang:-minimal})
4. Create LICENSE (${license_url})
5. Create README.md
6. Create GitHub repository (${visibility})
7. Push to branch: ${branch_name}
EOF
    exit 0
fi

# --------------------
# Repo creation
# --------------------
gh_args=("${repo}" "--${visibility}")
[[ -n "${repo_description}" ]] && gh_args+=("--description" "${repo_description}")

if [[ "${has_git}" == true ]]; then
    # Directory already has git, create repo and link it
    cd "${dir}"
    gh repo create "${gh_args[@]}" --source=. --remote=origin || true
else
    # Create new repo and clone into the target directory
    # Create remote repo first (without cloning)
    gh repo create "${gh_args[@]}"
    
    # Clone into parent directory, then move contents
    parent_dir="$(dirname "${dir}")"
    cd "${parent_dir}"
    
    # Clone to a temporary location
    temp_clone="${repo}_temp_$$"
    git clone "https://github.com/${github_username}/${repo}.git" "${temp_clone}"
    
    # Create target directory and move clone contents
    mkdir -p "${dir}"
    if [[ -d "${temp_clone}/.git" ]]; then
        mv "${temp_clone}/.git" "${dir}/"
        # Move any existing files from clone
        if [[ -n "$(ls -A "${temp_clone}" 2>/dev/null)" ]]; then
            mv "${temp_clone}"/* "${dir}/" 2>/dev/null || true
            mv "${temp_clone}"/.[!.]* "${dir}/" 2>/dev/null || true
        fi
    fi
    rm -rf "${temp_clone}"
    
    # Change to target directory
    cd "${dir}"
fi

REPO_CREATED=true

# --------------------
# LICENSE
# --------------------
if [[ "${license_url}" != "none" && ! -f LICENSE ]]; then
    license_body="$(curl -s "https://api.github.com/licenses/${license_url}" | jq -r '.body // empty')"
    if [[ -n "${license_body}" ]]; then
        echo "${license_body}" > LICENSE
    else
        log "Warning: Could not fetch license text for ${license_url}"
    fi
fi

# --------------------
# .gitignore
# --------------------
create_minimal_gitignore() {
    cat <<'EOF'
.DS_Store
.idea/
.vscode/
*.swp
EOF
}

if [[ ! -f .gitignore ]]; then
    if [[ -n "${prog_lang}" ]]; then
        # Capitalize first letter for GitHub gitignore URL (Bash 4.0+ required)
        lang_capitalized="${prog_lang^}"
        url="https://raw.githubusercontent.com/github/gitignore/master/${lang_capitalized}.gitignore"
        if curl -sf "${url}" -o .gitignore; then
            : # ok
        else
            create_minimal_gitignore >.gitignore
        fi
    else
        create_minimal_gitignore >.gitignore
    fi
fi

# --------------------
# README
# --------------------
if [[ ! -f README.md ]]; then
    cat >README.md <<EOF
# ${repo}

${repo_description:-Project description.}

## License
${license_url}
EOF
fi

# --------------------
# Git
# --------------------
git add .

if ! git diff --staged --quiet; then
    git commit -m "${commit_message}"
fi

current_branch="$(git branch --show-current 2>/dev/null)"
current_branch="${current_branch:-}"

if [[ "${current_branch}" != "${branch_name}" ]]; then
    git branch -M "${branch_name}"
fi

git push -u origin "${branch_name}"

echo "âœ“ Repository created: https://github.com/${github_username}/${repo}"

unset REPO_CREATED
